<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Page Title</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" type="text/css" media="screen" href="/assets/styles/styles.css" />
</head>

<body>
  <div id="app"></div>
  <script src="/bundle.js"></script>
  <div>
    <!-- <button onclick="resetPositions()">Reset</button>
    <canvas id="canvas" ref="canvas" height="500" width="500" style="border: 1px solid black" />
    <div style="display: none"}>
      <img id="emptyLogo" src="/assets/ia-logo-back.png" />
      <img id="redDot" src="/assets/ia-logo-dot-red.png" />
      <img id="blackDot" src="/assets/ia-logo-dot-black.png" />
      <img id="greenDot" src="/assets/ia-logo-dot-green.png" />
      <img id="blueDot" src="/assets/ia-logo-dot-blue.png" />
    </div> -->
  </div>

  <!-- <script>
    const style = {
      border: '1px solid black'
    }

    let currentDots;

    // const emptyLogo = <img src='/assets/ia-logo-back.png' />;
        // const { canvas, emptyLogo, redDot, blackDot, greenDot, blueDot } = document.querySelectorAll('*[id]');
        const canvas = document.getElementById('canvas');
        const emptyLogo = document.getElementById('emptyLogo');
        const redDot = document.getElementById('redDot');
        const blackDot = document.getElementById('blackDot');
        const greenDot = document.getElementById('greenDot');
        const blueDot = document.getElementById('blueDot');
        
        const ctx = canvas.getContext('2d');

        const initialDots = () => ([
          {
            x: 75,
            y: 100,
            w: 350,
            h: 350,
            src: emptyLogo,
            isDragging: false,
            notDraggable: true,
          },
          {
            x: 75,
            y: 25,
            w: 55,
            h: 55,
            src: redDot,
            type: 'red',
            isDragging: false,
            name: 'redDot'
          },
          {
            x: 150,
            y: 25,
            w: 55,
            h: 55,
            src: blackDot,
            type: 'black',
            isDragging: false,
            name: 'blackDot1'
          },
          {
            x: 220,
            y: 25,
            w: 55,
            h: 55,
            src: blackDot,
            type: 'black',
            isDragging: false,
            name: 'blackDot2'
          }, {
            x: 290,
            y: 25,
            w: 55,
            h: 55,
            src: greenDot,
            type: 'green',
            isDragging: false,
            name: 'greenDot'
          }, {
            x: 365,
            y: 25,
            w: 55,
            h: 55,
            src: blueDot,
            type: 'blue',
            isDragging: false,
            name: 'blueDot'
          },
        ]);

        let dotPositions = initialDots();
        // this.setState({ dotPositions: initialDots })


        ctx.drawImage(emptyLogo, 75, 100, 350, 350);
        initialDots().forEach(({ src, x, y, w, h }) => {
          console.log('newDot!: ', src, x, y, w, h)
          ctx.drawImage(src, x, y, w, h);
        })

        const resetPositions = () => {
          for (let solution in solutionLocations) {
            solutionLocations[solution].occupied = false;
          }
          dotPositions = initialDots();
          draw();
        }
        // const { canvas, emptyLogo, redDot, blackDot, greenDot, blueDot } = this.refs;
        // const ctx = this.refs.canvas.getContext('2d');
        const canvasBounds = canvas.getBoundingClientRect();
        const offsetX = canvasBounds.left;
        const offsetY = canvasBounds.top;
        let canDrag = true;
        let mouseX;
        let mouseY;

        // console.log('initialdots: ', initialDots);
        // const dotPositions = this.state.dotPositions;
        // console.log('canvas: ', this.refs.canvas);
        // ctx.fillRect(0,0,100,100);


        const mouseWithinDot = (dot) => {
          // mouseX > dot.x
          // && mouseX < (dot.x + dot.width)
          // && mouseY > dot.y
          // && mouseY < (dot.y + dot.height)
          // console.log('mouseX: ', mouseX)
          // console.log('mouseY: ', mouseY);
      
          if (mouseX > dot.x && mouseX < dot.x + dot.w && mouseY > dot.y && mouseY < dot.y + dot.h) {
            return true;
          }
          return false;
        }

        let startX;
        let startY;

        const mouseDown = (e) => {
          console.log('mouse down')
          e.preventDefault();
          e.stopPropagation();
          mouseX = parseInt(e.clientX) - offsetX;
          mouseY = parseInt(e.clientY) - offsetY;
          canDrag = false;

          for (let dot of dotPositions) {
            if (dot.notDraggable){
              continue;
            }
            console.log('checking dot: ', dot)
            console.log('mouseX, y: ', mouseX, mouseY)
            if (mouseWithinDot(dot)) {
              console.log('mousewithinDot!: ', dot);
              canDrag = true;
              dot.isDragging = true;
            }
          }

          startX = mouseX;
          startY = mouseY;

        }
        // Dot x, y + 28 each locatin
        
        const isDotInCircle = (midPoint, dotX, dotY) => {
          console.log('=============');
          const distanceSquared = Math.pow((dotX - midPoint.x + 30), 2) + Math.pow((dotY - midPoint.y + 30), 2)
          // console.log('dSquared: ', distanceSquared)
          const distance = Math.sqrt(distanceSquared);
          // console.log('distance: ', distance);
          if (42.5 > (distance + 27.5)) {
            console.log('*****match!!!*****')
            return true;
          }
            
          return false
        }
        
        const returnDotToStart = (dot) => {
          // console.log('dot in rDTS', dot);
          const initial = initialDots().find((initial) => initial.name === dot.name );
          // console.log('initial: ', initial.x, initial.y);
          dot.x = initial.x;
          dot.y = initial.y;
          draw();
          // console.log('lol')
        }

  
        // Solution Location dots 
        const solutionLocations = {
          black1: {
            dotLocation: {
              x: 100,
              y: 209
            },
            midPoint: {
              x: 128, 
              y: 235
            }, 
            type: 'black',
            occupied: false,
          }, 
          black2: {
            dotLocation: {
              x: 317,
              y: 265
            },
            midPoint: {
              x: 346,
              y: 293,
            }, 
            type: 'black',
            occupied: false,
          },
          red: {
            dotLocation: {
              x: 338,
              y: 138
            },
            midPoint: {
              x: 366,
              y: 166,
            },
            type: 'red',
            occupied: false,
          },
          blue: {
            dotLocation: {
              x: 233,
              y: 125
            },
             midPoint: {
              x: 260,
              y: 150,
            },
            type: 'blue',
            occupied: false,
          },
          green: {
            dotLocation: {
              x: 156,
              y: 293
            },
            midPoint: {
              x: 183,
              y: 318,
            },
            type: 'green',
            occupied: false,
          }
        }


      const handleDotOnTarget = () => {
        // console.log('solutionLocations: ', solutionLocations)  
        dotPositions.forEach((dot, i) => { 
            dot.isDragging = false;
            for (let solution in solutionLocations) {
              const target = solutionLocations[solution];
              if (isDotInCircle(target.midPoint, dot.x, dot.y)){
                console.log('dotInCircle!');
                console.log('dot.type: ', dot.type);
                console.log('target.type: ', target.type);
                
              }
              // console.log('isDotInCircle: ', isDotInCircle(target.midPoint, dot.x, dot.y))
              if (!target.occupied && dot.type === target.type && isDotInCircle(target.midPoint, dot.x, dot.y)) {
                console.log('match!: ', dot, target)
                console.log('dot before: ', dot.x, dot.y)
                // dot.x = target.dotLocation.x;
                // dot.y = target.dotLocation.y;
                dotPositions[i].x = target.dotLocation.x;
                dotPositions[i].y = target.dotLocation.y;
                dotPositions[i].notDraggable = true;
                dotPositions[i].isComplete = true;
                target.occupied = true;
                draw();
                
                console.log('dot after: ', dot.x, dot.y)
                setTimeout( checkFinished, 150);
              } 
            }
            !dotPositions[i].isComplete && returnDotToStart(dot);
        })
      }

        const solutionCircle = {

        }
        const checkFinished = () => {
          const count = Object.keys(solutionLocations).reduce((tv, cv) => {
            return solutionLocations[cv].occupied ? ++tv : tv;
          },0);
          count === 5 && alert('Task successfully complete!');
        }

        const mouseMove = (e) => {
          if (canDrag) {
            e.preventDefault();
            e.stopPropagation();

            const mouseX = parseInt(e.clientX) - offsetX;
            const mouseY = parseInt(e.clientY) - offsetY;

            const dX = mouseX - startX;
            const dY = mouseY - startY;

            for (let dot of dotPositions) {
              if (dot.isDragging) {
                dot.x += dX;
                dot.y += dY;
              }
            }

            draw();

            startX = mouseX;
            startY = mouseY;

          }
        }

        const clearCanvas = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height)
        }

        const draw = () => {
          clearCanvas();
          dotPositions.forEach(({ src, x, y, w, h }) => {
            ctx.drawImage(src, x, y, w, h);
          })
          // console.log('redrawn');
        }

        const mouseUp = (e) => {
            e.preventDefault();
            e.stopPropagation();
            canDrag = false;
            console.log('location on up: ', { 'x': mouseX, 'y': mouseY});
            // console.log('mouseX: ', mouseY);
            
            // console.log('dotPositionsin mU: ', dotPositions);
            handleDotOnTarget()
            // console.log('dotPositions: ', dotPositions)
          }


        canvas.onmousedown = mouseDown;
        canvas.onmouseup = mouseUp
        canvas.onmousemove = mouseMove

        // ctx.drawImage(redDot, 75, 25, 55, 55);
        // ctx.drawImage(blackDot, 150, 25, 55, 55);
        // ctx.drawImage(blackDot, 220, 25, 55, 55);
        // ctx.drawImage(greenDot, 290, 25, 55, 55);
        // ctx.drawImage(blueDot, 365, 25, 55, 55);






// // get canvas related references
// var canvas = document.getElementById("canvas");
// var ctx = canvas.getContext("2d");
// var BB = canvas.getBoundingClientRect();
// var offsetX = BB.left;
// var offsetY = BB.top;
// var WIDTH = canvas.width;
// var HEIGHT = canvas.height;

// // drag related variables
// var dragok = false;
// var startX;
// var startY;

// // an array of objects that define different rectangles
// var rects = [];
// rects.push({
//   x: 75 - 15,
//   y: 50 - 15,
//   width: 30,
//   height: 30,
//   fill: "#444444",
//   isDragging: false
// });
// rects.push({
//   x: 75 - 25,
//   y: 50 - 25,
//   width: 30,
//   height: 30,
//   fill: "#ff550d",
//   isDragging: false
// });
// rects.push({
//   x: 75 - 35,
//   y: 50 - 35,
//   width: 30,
//   height: 30,
//   fill: "#800080",
//   isDragging: false
// });
// rects.push({
//   x: 75 - 45,
//   y: 50 - 45,
//   width: 30,
//   height: 30,
//   fill: "#0c64e8",
//   isDragging: false
// });

// // listen for mouse events
// canvas.onmousedown = myDown;
// canvas.onmouseup = myUp;
// canvas.onmousemove = myMove;

// // call to draw the scene
// draw();

// // draw a single rect
// function rect(x, y, w, h) {
//   ctx.beginPath();
//   ctx.rect(x, y, w, h);
//   ctx.closePath();
//   ctx.fill();
// }

// // clear the canvas
// function clear() {
//   ctx.clearRect(0, 0, WIDTH, HEIGHT);
// }

// // redraw the scene
// function draw() {
//   clear();
//   ctx.fillStyle = "#FAF7F8";
//   rect(0, 0, WIDTH, HEIGHT);
//   // redraw each rect in the rects[] array
//   for (var i = 0; i < rects.length; i++) {
//     var r = rects[i];
//     ctx.fillStyle = r.fill;
//     rect(r.x, r.y, r.width, r.height);
//   }
// }


// // handle mousedown events
// function myDown(e) {

//   // tell the browser we're handling this mouse event
//   e.preventDefault();
//   e.stopPropagation();

//   // get the current mouse position
//   var mx = parseInt(e.clientX - offsetX);
//   var my = parseInt(e.clientY - offsetY);

//   // test each rect to see if mouse is inside
//   dragok = false;
//   for (var i = 0; i < rects.length; i++) {
//     var r = rects[i];
//     if (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height) {
//       // if yes, set that rects isDragging=true
//       dragok = true;
//       r.isDragging = true;
//     }
//   }
//   // save the current mouse position
//   startX = mx;
//   startY = my;
// }


// // handle mouseup events
// function myUp(e) {
//   // tell the browser we're handling this mouse event
//   e.preventDefault();
//   e.stopPropagation();

//   // clear all the dragging flags
//   dragok = false;
//   for (var i = 0; i < rects.length; i++) {
//     rects[i].isDragging = false;
//   }
// }


// // handle mouse moves
// function myMove(e) {
//   // if we're dragging anything...
//   if (dragok) {

//     // tell the browser we're handling this mouse event
//     e.preventDefault();
//     e.stopPropagation();

//     // get the current mouse position
//     var mx = parseInt(e.clientX - offsetX);
//     var my = parseInt(e.clientY - offsetY);

//     // calculate the distance the mouse has moved
//     // since the last mousemove
//     var dx = mx - startX;
//     var dy = my - startY;

//     // move each rect that isDragging 
//     // by the distance the mouse has moved
//     // since the last mousemove
//     for (var i = 0; i < rects.length; i++) {
//       var r = rects[i];
//       if (r.isDragging) {
//         r.x += dx;
//         r.y += dy;
//       }
//     }

//     // redraw the scene with the new rect positions
//     draw();

//     // reset the starting mouse position for the next mousemove
//     startX = mx;
//     startY = my;

//   }
// }
  </script> -->
</body>

</html>